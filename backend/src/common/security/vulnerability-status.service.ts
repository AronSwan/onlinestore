import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { AuditLogEntity } from '../audit/entities/audit-log.entity';
import * as fs from 'fs';
import * as path from 'path';

/**
 * 漏洞状态服务
 * 用于从审计日志中提取漏洞状态变化信息
 */
@Injectable()
export class VulnerabilityStatusService {
  private readonly logger = new Logger(VulnerabilityStatusService.name);

  constructor(
    @InjectRepository(AuditLogEntity)
    private auditLogRepository: Repository<AuditLogEntity>,
  ) {}

  /**
   * 从审计日志中获取漏洞状态变化
   */
  async getVulnerabilityStatusChanges(): Promise<any[]> {
    try {
      // 查询与漏洞相关的审计日志
      const vulnerabilityLogs = await this.auditLogRepository
        .createQueryBuilder('audit')
        .where('audit.operation LIKE :operation', { operation: '%VULN%' })
        .orWhere('audit.module = :module', { module: 'security' })
        .orderBy('audit.createTime', 'DESC')
        .limit(100)
        .getMany();

      // 处理审计日志，提取漏洞状态变化
      const statusChanges = this.processAuditLogs(vulnerabilityLogs);

      return statusChanges;
    } catch (error) {
      this.logger.error('获取漏洞状态变化失败', error);
      return [];
    }
  }

  /**
   * 处理审计日志，提取漏洞状态变化
   */
  private processAuditLogs(logs: AuditLogEntity[]): any[] {
    const statusChanges: any[] = [];

    logs.forEach(log => {
      try {
        // 解析请求参数和响应数据
        const requestParams = JSON.parse(log.requestParams || '{}');
        const responseData = JSON.parse(log.responseData || '{}');

        // 检查是否是漏洞状态更新操作
        if (this.isVulnerabilityStatusUpdate(log.operation)) {
          const vulnerabilityId = this.extractVulnerabilityId(requestParams, responseData);
          const oldStatus = this.extractOldStatus(requestParams);
          const newStatus = this.extractNewStatus(responseData);

          if (vulnerabilityId && oldStatus && newStatus) {
            statusChanges.push({
              vulnerabilityId,
              oldStatus,
              newStatus,
              changeDate: log.createTime,
              changedBy: log.userName,
              operation: log.operation,
              module: log.module,
            });
          }
        }
      } catch (error) {
        this.logger.warn(`处理审计日志失败: ${log.id}`, error);
      }
    });

    return statusChanges;
  }

  /**
   * 检查是否是漏洞状态更新操作
   */
  private isVulnerabilityStatusUpdate(operation: string): boolean {
    const statusUpdateOperations = [
      'VULN_STATUS_UPDATE',
      'VULN_FIX',
      'VULN_VERIFY',
      'VULN_CLOSE',
      'VULN_REOPEN',
      'SECURITY_VULNERABILITY_UPDATE',
    ];

    return statusUpdateOperations.some(op => operation.includes(op));
  }

  /**
   * 从请求参数或响应数据中提取漏洞ID
   */
  private extractVulnerabilityId(requestParams: any, responseData: any): string | null {
    // 尝试从请求参数中提取
    if (requestParams.vulnerabilityId) {
      return requestParams.vulnerabilityId;
    }

    if (requestParams.id) {
      return requestParams.id;
    }

    // 尝试从响应数据中提取
    if (responseData.vulnerabilityId) {
      return responseData.vulnerabilityId;
    }

    if (responseData.id) {
      return responseData.id;
    }

    return null;
  }

  /**
   * 从请求参数中提取旧状态
   */
  private extractOldStatus(requestParams: any): string | null {
    if (requestParams.oldStatus) {
      return requestParams.oldStatus;
    }

    if (requestParams.status) {
      return requestParams.status;
    }

    return null;
  }

  /**
   * 从响应数据中提取新状态
   */
  private extractNewStatus(responseData: any): string | null {
    if (responseData.newStatus) {
      return responseData.newStatus;
    }

    if (responseData.status) {
      return responseData.status;
    }

    return null;
  }

  /**
   * 更新漏洞数据文件中的状态
   */
  async updateVulnerabilityDataFile(): Promise<boolean> {
    try {
      // 获取漏洞状态变化
      const statusChanges = await this.getVulnerabilityStatusChanges();

      if (statusChanges.length === 0) {
        this.logger.log('没有找到漏洞状态变化');
        return true;
      }

      // 读取漏洞数据文件
      const filePath = path.join(process.cwd(), 'data/security-vulnerabilities.json');

      if (!fs.existsSync(filePath)) {
        this.logger.error(`漏洞数据文件不存在: ${filePath}`);
        return false;
      }

      const fileContent = fs.readFileSync(filePath, 'utf-8');
      const vulnerabilityData = JSON.parse(fileContent);

      // 应用状态变化
      let updatedCount = 0;
      statusChanges.forEach(change => {
        const vulnerability = vulnerabilityData.vulnerabilities.find(
          (v: any) => v.id === change.vulnerabilityId,
        );

        if (vulnerability) {
          vulnerability.status = this.convertStatusToChinese(change.newStatus);

          // 添加状态变化相关的日期
          if (change.newStatus === 'resolved' || change.newStatus === 'completed') {
            vulnerability.completedDate = change.changeDate.toISOString().split('T')[0];
          } else if (change.newStatus === 'in-progress') {
            vulnerability.inProgressDate = change.changeDate.toISOString().split('T')[0];
          } else if (change.newStatus === 'pending-retest') {
            vulnerability.completedDate = change.changeDate.toISOString().split('T')[0];
          } else if (change.newStatus === 'risk-accepted') {
            vulnerability.acceptedDate = change.changeDate.toISOString().split('T')[0];
          }

          updatedCount++;
          this.logger.log(`更新漏洞 ${vulnerability.id} 状态为 ${vulnerability.status}`);
        }
      });

      // 更新元数据
      vulnerabilityData.metadata.lastUpdated = new Date().toISOString().split('T')[0];

      // 保存更新后的文件
      fs.writeFileSync(filePath, JSON.stringify(vulnerabilityData, null, 2));

      this.logger.log(`成功更新 ${updatedCount} 个漏洞状态`);
      return true;
    } catch (error) {
      this.logger.error('更新漏洞数据文件失败', error);
      return false;
    }
  }

  /**
   * 将英文状态转换为中文
   */
  private convertStatusToChinese(status: string): string {
    const statusMap: Record<string, string> = {
      discovered: '发现',
      confirmed: '确认',
      open: '待修复',
      'in-progress': '进行中',
      'pending-retest': '待复测',
      resolved: '已完成',
      completed: '已完成',
      'risk-accepted': '风险接受',
    };

    return statusMap[status] || status;
  }

  /**
   * 生成模拟的漏洞状态变化审计日志
   * 用于演示目的
   */
  async generateMockAuditLogs(): Promise<void> {
    try {
      const mockLogs = [
        {
          operation: 'VULN_STATUS_UPDATE',
          module: 'security',
          userId: 'user1',
          userName: '张三',
          requestParams: JSON.stringify({
            vulnerabilityId: 'VULN-001',
            oldStatus: 'open',
            newStatus: 'resolved',
          }),
          responseData: JSON.stringify({
            id: 'VULN-001',
            status: 'resolved',
          }),
          status: 'SUCCESS',
          createTime: new Date('2025-10-03T10:00:00Z'),
        },
        {
          operation: 'VULN_STATUS_UPDATE',
          module: 'security',
          userId: 'user2',
          userName: '李四',
          requestParams: JSON.stringify({
            vulnerabilityId: 'VULN-002',
            oldStatus: 'open',
            newStatus: 'in-progress',
          }),
          responseData: JSON.stringify({
            id: 'VULN-002',
            status: 'in-progress',
          }),
          status: 'SUCCESS',
          createTime: new Date('2025-10-03T11:00:00Z'),
        },
        {
          operation: 'VULN_STATUS_UPDATE',
          module: 'security',
          userId: 'user3',
          userName: '王五',
          requestParams: JSON.stringify({
            vulnerabilityId: 'VULN-003',
            oldStatus: 'open',
            newStatus: 'pending-retest',
          }),
          responseData: JSON.stringify({
            id: 'VULN-003',
            status: 'pending-retest',
          }),
          status: 'SUCCESS',
          createTime: new Date('2025-10-03T12:00:00Z'),
        },
        {
          operation: 'VULN_STATUS_UPDATE',
          module: 'security',
          userId: 'user4',
          userName: '赵六',
          requestParams: JSON.stringify({
            vulnerabilityId: 'VULN-004',
            oldStatus: 'open',
            newStatus: 'resolved',
          }),
          responseData: JSON.stringify({
            id: 'VULN-004',
            status: 'resolved',
          }),
          status: 'SUCCESS',
          createTime: new Date('2025-10-03T13:00:00Z'),
        },
        {
          operation: 'VULN_STATUS_UPDATE',
          module: 'security',
          userId: 'user5',
          userName: '钱七',
          requestParams: JSON.stringify({
            vulnerabilityId: 'VULN-005',
            oldStatus: 'open',
            newStatus: 'risk-accepted',
          }),
          responseData: JSON.stringify({
            id: 'VULN-005',
            status: 'risk-accepted',
          }),
          status: 'SUCCESS',
          createTime: new Date('2025-10-03T14:00:00Z'),
        },
      ];

      // 保存模拟日志到数据库
      for (const logData of mockLogs) {
        const auditLog = this.auditLogRepository.create(logData);
        await this.auditLogRepository.save(auditLog);
      }

      this.logger.log(`成功生成 ${mockLogs.length} 条模拟审计日志`);
    } catch (error) {
      this.logger.error('生成模拟审计日志失败', error);
    }
  }
}
