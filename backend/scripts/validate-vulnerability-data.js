#!/usr/bin/env node

/**
 * 漏洞数据验证脚本
 * 用途: 验证security-vulnerabilities.json文件的数据结构
 * 使用方法:
 *   npm run security:validate-data
 *   npm run security:validate-data -- --format=json --output=validation-report.json
 *   npm run security:validate-data:ci
 * @author 安全团队
 * @version 1.0.0
 * @since 2025-10-03
 */

const fs = require('fs');
const path = require('path');

// 项目根目录
const PROJECT_ROOT = path.resolve(__dirname, '..');

// 默认配置
const DEFAULT_CONFIG = {
  dataFile: 'data/security-vulnerabilities.json',
  schemaFile: 'data/security-vulnerabilities.schema.json',
  reportFile: 'validation-report.json',
  ciMode: false
};

/**
 * 验证JSON数据结构
 * @param {Object} data - 要验证的数据
 * @param {Object} schema - JSON Schema
 * @returns {Object} 验证结果
 */
function validateJsonSchema(data, schema) {
  // 简单的JSON Schema验证实现
  // 在实际项目中，建议使用ajv等专业的JSON Schema验证库
  const result = {
    valid: true,
    errors: [],
    warnings: []
  };
  
  // 验证根对象
  if (typeof data !== 'object' || data === null) {
    result.valid = false;
    result.errors.push('根元素必须是对象');
    return result;
  }
  
  // 验证必需字段
  const requiredFields = ['metadata', 'workflow', 'statusDictionary', 'vulnerabilities'];
  for (const field of requiredFields) {
    if (!(field in data)) {
      result.valid = false;
      result.errors.push(`缺少必需字段: ${field}`);
    }
  }
  
  // 验证metadata
  if (data.metadata) {
    validateMetadata(data.metadata, result);
  }
  
  // 验证vulnerabilities数组
  if (data.vulnerabilities) {
    if (!Array.isArray(data.vulnerabilities)) {
      result.valid = false;
      result.errors.push('vulnerabilities必须是数组');
    } else if (data.vulnerabilities.length === 0) {
      result.warnings.push('vulnerabilities数组为空');
    } else {
      validateVulnerabilities(data.vulnerabilities, result);
    }
  }
  
  return result;
}

/**
 * 验证metadata字段
 * @param {Object} metadata - metadata对象
 * @param {Object} result - 验证结果对象
 */
function validateMetadata(metadata, result) {
  const requiredFields = ['version', 'lastUpdated', 'maintainer', 'effectiveDate', 'auditDate', 'codeBranch', 'commitHash', 'environment'];
  
  for (const field of requiredFields) {
    if (!(field in metadata)) {
      result.valid = false;
      result.errors.push(`metadata缺少必需字段: ${field}`);
    } else if (typeof metadata[field] !== 'string' || metadata[field].trim() === '') {
      result.valid = false;
      result.errors.push(`metadata.${field}必须是非空字符串`);
    }
  }
  
  // 验证版本号格式
  if (metadata.version && !/^\d+\.\d+\.\d+$/.test(metadata.version)) {
    result.valid = false;
    result.errors.push('metadata.version格式不正确，应为x.y.z');
  }
  
  // 验证日期格式
  const dateFields = ['lastUpdated', 'effectiveDate', 'auditDate'];
  for (const field of dateFields) {
    if (metadata[field] && !/^\d{4}-\d{2}-\d{2}$/.test(metadata[field])) {
      result.valid = false;
      result.errors.push(`metadata.${field}格式不正确，应为YYYY-MM-DD`);
    }
  }
  
  // 验证环境
  if (metadata.environment && !['开发环境', '测试环境', '预生产环境', '生产环境'].includes(metadata.environment)) {
    result.valid = false;
    result.errors.push('metadata.environment值不正确');
  }
}

/**
 * 验证漏洞数组
 * @param {Array} vulnerabilities - 漏洞数组
 * @param {Object} result - 验证结果对象
 */
function validateVulnerabilities(vulnerabilities, result) {
  const seenIds = new Set();
  
  for (let i = 0; i < vulnerabilities.length; i++) {
    const vuln = vulnerabilities[i];
    const prefix = `vulnerabilities[${i}]`;
    
    // 验证必需字段
    const requiredFields = ['id', 'title', 'ruleId', 'cvss', 'severity', 'status', 'owner', 'firstFound', 'targetDate'];
    for (const field of requiredFields) {
      if (!(field in vuln)) {
        result.valid = false;
        result.errors.push(`${prefix}缺少必需字段: ${field}`);
      }
    }
    
    // 验证ID格式
    if (vuln.id) {
      if (!/^VULN-\d+$/.test(vuln.id)) {
        result.valid = false;
        result.errors.push(`${prefix}.id格式不正确，应为VULN-XXX`);
      }
      
      // 检查ID重复
      if (seenIds.has(vuln.id)) {
        result.valid = false;
        result.errors.push(`${prefix}.id重复: ${vuln.id}`);
      } else {
        seenIds.add(vuln.id);
      }
    }
    
    // 验证CVSS评分
    if (vuln.cvss !== undefined) {
      if (typeof vuln.cvss !== 'number' || vuln.cvss < 0 || vuln.cvss > 10) {
        result.valid = false;
        result.errors.push(`${prefix}.cvss必须是0-10之间的数字`);
      }
    }
    
    // 验证严重度
    if (vuln.severity && !['低', '中', '高', '严重'].includes(vuln.severity)) {
      result.valid = false;
      result.errors.push(`${prefix}.severity值不正确`);
    }
    
    // 验证状态
    if (vuln.status && !['发现', '确认', '待修复', '进行中', '待复测', '已完成', '风险接受'].includes(vuln.status)) {
      result.valid = false;
      result.errors.push(`${prefix}.status值不正确`);
    }
    
    // 验证日期格式
    const dateFields = ['firstFound', 'targetDate'];
    for (const field of dateFields) {
      if (vuln[field] && !/^\d{4}-\d{2}-\d{2}$/.test(vuln[field])) {
        result.valid = false;
        result.errors.push(`${prefix}.${field}格式不正确，应为YYYY-MM-DD`);
      }
    }
    
    // 验证证据链接
    if (vuln.evidenceLinks) {
      if (!Array.isArray(vuln.evidenceLinks)) {
        result.valid = false;
        result.errors.push(`${prefix}.evidenceLinks必须是数组`);
      } else if (vuln.evidenceLinks.length === 0) {
        result.warnings.push(`${prefix}.evidenceLinks数组为空`);
      } else {
        validateEvidenceLinks(vuln.evidenceLinks, `${prefix}.evidenceLinks`, result);
      }
    }
  }
}

/**
 * 验证证据链接
 * @param {Array} evidenceLinks - 证据链接数组
 * @param {string} prefix - 字段前缀
 * @param {Object} result - 验证结果对象
 */
function validateEvidenceLinks(evidenceLinks, prefix, result) {
  for (let i = 0; i < evidenceLinks.length; i++) {
    const link = evidenceLinks[i];
    const fieldPrefix = `${prefix}[${i}]`;
    
    // 验证必需字段
    const requiredFields = ['type', 'url', 'description'];
    for (const field of requiredFields) {
      if (!(field in link)) {
        result.valid = false;
        result.errors.push(`${fieldPrefix}缺少必需字段: ${field}`);
      }
    }
    
    // 验证类型
    if (link.type && !['日志', 'PoC', '测试报告', '截图', '视频', '代码位置'].includes(link.type)) {
      result.valid = false;
      result.errors.push(`${fieldPrefix}.type值不正确`);
    }
    
    // 验证URL格式
    if (link.url && !/^[a-zA-Z0-9/._-]+$/.test(link.url)) {
      result.valid = false;
      result.errors.push(`${fieldPrefix}.url格式不正确`);
    }
  }
}

/**
 * 生成验证报告
 * @param {Object} validationResult - 验证结果
 * @param {string} dataFile - 数据文件路径
 * @param {string} schemaFile - Schema文件路径
 * @returns {Object} 验证报告
 */
function generateValidationReport(validationResult, dataFile, schemaFile) {
  const report = {
    timestamp: new Date().toISOString(),
    dataFile,
    schemaFile,
    valid: validationResult.valid,
    summary: {
      errors: validationResult.errors.length,
      warnings: validationResult.warnings.length
    },
    errors: validationResult.errors,
    warnings: validationResult.warnings
  };
  
  return report;
}

/**
 * 主函数
 * @param {Object} options - 选项对象
 */
function validateVulnerabilityData(options = {}) {
  const config = { ...DEFAULT_CONFIG, ...options };
  
  try {
    console.log('开始验证漏洞数据...');
    
    // 读取数据文件
    const dataFilePath = path.join(PROJECT_ROOT, config.dataFile);
    if (!fs.existsSync(dataFilePath)) {
      throw new Error(`数据文件不存在: ${dataFilePath}`);
    }
    
    const dataContent = fs.readFileSync(dataFilePath, 'utf8');
    let data;
    try {
      data = JSON.parse(dataContent);
    } catch (parseError) {
      throw new Error(`数据文件JSON格式错误: ${parseError.message}`);
    }
    
    // 读取Schema文件
    const schemaFilePath = path.join(PROJECT_ROOT, config.schemaFile);
    if (!fs.existsSync(schemaFilePath)) {
      throw new Error(`Schema文件不存在: ${schemaFilePath}`);
    }
    
    const schemaContent = fs.readFileSync(schemaFilePath, 'utf8');
    let schema;
    try {
      schema = JSON.parse(schemaContent);
    } catch (parseError) {
      throw new Error(`Schema文件JSON格式错误: ${parseError.message}`);
    }
    
    // 验证数据
    const validationResult = validateJsonSchema(data, schema);
    
    // 生成报告
    const report = generateValidationReport(validationResult, config.dataFile, config.schemaFile);
    
    // 输出结果
    if (config.ciMode || config.format === 'json') {
      if (config.output) {
        const reportPath = path.join(PROJECT_ROOT, config.output);
        fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
        console.log(`验证报告已生成: ${reportPath}`);
      } else {
        console.log(JSON.stringify(report, null, 2));
      }
    } else {
      // 控制台友好输出
      console.log(`\n验证结果: ${report.valid ? '通过' : '失败'}`);
      console.log(`错误: ${report.summary.errors}`);
      console.log(`警告: ${report.summary.warnings}`);
      
      if (report.errors.length > 0) {
        console.log('\n错误详情:');
        report.errors.forEach((error, index) => {
          console.log(`${index + 1}. ${error}`);
        });
      }
      
      if (report.warnings.length > 0) {
        console.log('\n警告详情:');
        report.warnings.forEach((warning, index) => {
          console.log(`${index + 1}. ${warning}`);
        });
      }
    }
    
    // 在CI模式下，如果验证失败则退出
    if (config.ciMode && !report.valid) {
      console.error('数据验证失败，CI检查未通过');
      process.exit(1);
    }
    
    return report;
  } catch (error) {
    console.error(`验证过程出错: ${error.message}`);
    if (config.ciMode) {
      process.exit(1);
    } else {
      throw error;
    }
  }
}

// 解析命令行参数
function parseArgs() {
  const args = process.argv.slice(2);
  const options = {};
  
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    
    if (arg === '--format' && i + 1 < args.length) {
      options.format = args[++i];
    } else if (arg === '--output' && i + 1 < args.length) {
      options.output = args[++i];
    } else if (arg === '--ci') {
      options.ciMode = true;
    } else if (arg === '--data-file' && i + 1 < args.length) {
      options.dataFile = args[++i];
    } else if (arg === '--schema-file' && i + 1 < args.length) {
      options.schemaFile = args[++i];
    }
  }
  
  return options;
}

// 运行验证
if (require.main === module) {
  const options = parseArgs();
  validateVulnerabilityData(options);
}

module.exports = { validateVulnerabilityData, validateJsonSchema };